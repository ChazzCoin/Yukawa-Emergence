# The Unified Alignment Dirac Operator v5.0

## 0. Design constraints that v5.0 must satisfy

### Evenness

The full triple must admit a grading (\Gamma) with
[
\Gamma^\ast=\Gamma,\qquad \Gamma^2=1,\qquad {\Gamma,D}=0,\qquad [\Gamma,\pi(A)]=0.
]
Therefore **no standalone “pure flavor” term** of the form (\gamma_{\rm geom}\otimes 1\otimes D_{\rm flav}) is allowed, because it commutes with (\Gamma) and would spoil ({\Gamma,D}=0).

### Flavor multiplicity

Flavor is a **multiplicity factor**:
[
\pi(A)\subseteq \mathcal B(H_{\rm geom}\otimes H_{\rm SM})\otimes 1_{\rm flav},
]
so there is **no** extra commutative diagonal “site algebra” acting on (H_{\rm flav}). This is the v4.0 structural cure that protects order-zero and first-order.

### Commutant protection

All flavor/Yukawa textures are chosen in the commutant:
[
Y[\mathcal K]\in \pi(A)',,
]
so inner fluctuations do not generate “generation-gauge” bosons; they only produce the usual gauge/Higgs degrees of freedom.

---

## 1. The spectral datum and the even product Dirac operator

### 1.1 Spaces and algebra

Assume:

* A real, even geometric triple ((A_{\rm geom},H_{\rm geom},D_{\rm geom},J_{\rm geom},\gamma_{\rm geom})).
* A real, even finite SM triple ((A_{\rm SM},H_{\rm SM},D_{\rm SM},J_{\rm SM},\gamma_{\rm SM})) (one-generation internal geometry).
* A finite-dimensional multiplicity space (H_{\rm flav}\cong\mathbb C^N) with antiunitary (J_{\rm flav}=U_{\rm flav}\circ K).

Define
[
A:=A_{\rm geom}\otimes A_{\rm SM},\qquad
H:=H_{\rm geom}\otimes H_{\rm SM}\otimes H_{\rm flav},
]
[
\pi(a_{\rm geom}\otimes a_{\rm SM})
===================================

\pi_{\rm geom}(a_{\rm geom})\otimes \pi_{\rm SM}(a_{\rm SM})\otimes 1_{\rm flav}.
]

### 1.2 The even product Dirac operator

The v4.0 unfluctuated Dirac operator is **by definition**
[
D
=

D_{\rm geom}\otimes 1\otimes 1
;+;
\gamma_{\rm geom}\otimes D_{\rm int}(Y[\mathcal K]),
]
where (D_{\rm int}(Y[\mathcal K])) acts on (H_{\rm SM}\otimes H_{\rm flav}) and is **odd** with respect to (\gamma_{\rm SM}\otimes 1):
[
{\gamma_{\rm SM}\otimes 1,;D_{\rm int}(Y[\mathcal K])}=0.
]

The total grading and real structure are
[
\Gamma:=\gamma_{\rm geom}\otimes \gamma_{\rm SM}\otimes 1_{\rm flav},\qquad
J:=J_{\rm geom}\otimes J_{\rm SM}\otimes J_{\rm flav}.
]

This is the v4.0 “even product” lock: all mixing must appear **inside** the odd internal operator (D_{\rm int}), never as an even add-on.

---

## 2. Where the hierarchy and mixing live (without breaking axioms)

### 2.1 Flavor textures as commutant operators

The alignment hierarchy is encoded in operators on (H_{\rm flav}), for example using your (\kappa)-distance kernel on sites ({1,2,5}):
[
(Y_{\rm flav})*{ij}=\kappa^{|n_i-n_j|},
\qquad {n_i}={1,2,5}.
]
But in v4.0 this object is **not** itself “the finite algebra”; it is a **commutant texture** acting on the multiplicity factor and inserted into the LR blocks of (D*{\rm int}).

Formally, require
[
Y_{\rm flav}\in \pi(A)'\quad\text{(commutant condition)}.
]

### 2.2 The internal Dirac operator as an odd LR-coupler

Write the internal operator in chiral block form (on (H_{\rm SM}\otimes H_{\rm flav})):
[
D_{\rm int}(Y[\mathcal K])
==========================

\begin{pmatrix}
0 & \mathcal Y^\dagger \
\mathcal Y & 0
\end{pmatrix}
;\oplus;
\text{(possible Majorana blocks)}.
]
Here (\mathcal Y) is the LR coupling operator, built sector-by-sector using SM projectors and your flavor textures. Schematically:
[
\mathcal Y
==========

P_u\otimes Y_u[\mathcal K]
+
P_d\otimes Y_d[\mathcal K]
+
P_e\otimes Y_e[\mathcal K]
+
P_\nu\otimes Y_\nu[\mathcal K],
]
with (P_u,P_d,P_e,P_\nu) acting on (H_{\rm SM}) and (Y_x[\mathcal K]) acting on (H_{\rm flav}). Each (Y_x[\mathcal K]) is generated by your kernel pipeline and lies in (\pi(A)').

### 2.3 Neutrino seesaw (if included)

If you include Majorana masses, they belong in the internal operator as additional blocks (Takagi/real structure compatible), not as a “fluctuation trick”. The reality structure (J) constrains the allowed form; it does not “create” the scale by itself.

---

## 3. Inner fluctuations and the unified operator

### 3.1 One-forms and fluctuations

Define the represented one-forms
[
\Omega_D^1(A)
:=
\left{
\sum_i \pi(a_i)[D,\pi(b_i)] : a_i,b_i\in A
\right}
\subset \mathcal B(H).
]
Given (A_1\in\Omega_D^1(A)), take its Hermitian part
[
A:=\tfrac12(A_1+A_1^\dagger),
]
and define the fluctuated operator
[
D_A:=D + A + JAJ^{-1}.
]

### 3.2 What fluctuations generate (and what they do not)

* **Generated by fluctuations:** gauge bosons and Higgs fields associated to the represented algebra (A=A_{\rm geom}\otimes A_{\rm SM}).
* **Not generated by fluctuations:** Yukawa textures. Those live in (D_{\rm int}(Y[\mathcal K])) by construction; fluctuations Higgs-dress them.

### 3.3 The antiunitary implementation rule

In a fixed matrix basis, if (J=U_J\circ K), then
[
JXJ^{-1}=U_J,\overline{X},U_J^\dagger.
]
This must be used for the (JAJ^{-1}) term.

---

## 4. The final unified operator (v4.0 canonical form)

[
\boxed{
D_A
===

\underbrace{D_{\rm geom}\otimes 1\otimes 1}*{\text{geometric phase-gradient}}
+
\underbrace{\gamma*{\rm geom}\otimes D_{\rm int}(Y[\mathcal K])}*{\text{odd internal LR + textures}}
+
\underbrace{A}*{\text{gauge + Higgs from inner fluctuations}}
+
\underbrace{JAJ^{-1}}_{\text{reality completion}}
}
]

This is the single operator compatible with:

* evenness,
* flavor multiplicity,
* commutant protection,
* order-zero and first-order stability.

---

## 5. Spectral action (what becomes computable once (D_A) is fixed)

With
[
S=\operatorname{Tr},f!\left(\frac{D_A^2}{\Lambda^2}\right),
]
the standard heat-kernel expansion yields:

* geometric terms (from (D_{\rm geom})),
* gauge kinetic terms (from fluctuations),
* Higgs kinetic and potential (from internal fluctuations),
* Yukawa normalization and fermion masses (from (D_{\rm int}(Y[\mathcal K])) Higgs-dressed),
* neutrino seesaw structure (if Majorana blocks are included in (D_{\rm int})).

The unification is real: everything is encoded in one spectral datum—without violating the axioms.

---

## 6. Production commutator gates (norm-corrected)

Fix a finite spanning/generating set (\mathcal G_A\subset A). On truncations use the operator norm (|\cdot|).

[
\max_{a,b\in\mathcal G_A}\ \big|[\pi(a),J\pi(b)J^{-1}]\big|\le \varepsilon_0,
]
[
\max_{a,b\in\mathcal G_A}\ \big|[[D,\pi(a)],J\pi(b)J^{-1}]\big|\le \varepsilon_1,
]
[
|D_A-D_A^\dagger|\le \varepsilon_{\rm sa},
\qquad
\max_{a,b\in\mathcal G_A}\ \big|[[D_A,\pi(a)],J\pi(b)J^{-1}]\big|\le \varepsilon_A.
]

---

## 7. Updated implementation skeleton (v4.0 structural correctness)

This skeleton only encodes the **structural** requirements: even product form, Hermitian one-forms, antiunitary (J), and projector-defined Yukawa extraction.

```python
import numpy as np

def antiunitary_conjugation(UJ: np.ndarray, X: np.ndarray) -> np.ndarray:
    """
    J X J^{-1} for J = UJ ∘ K.
    """
    return UJ @ X.conj() @ UJ.conj().T


class UnifiedAlignmentDiracV4:
    """
    Builds the v4.0 even-product unified operator:
      D   = D_geom ⊗ 1 ⊗ 1  +  gamma_geom ⊗ D_int(Y[K])
      D_A = D + A + J A J^{-1}
    """

    def __init__(self,
                 D_geom_full: np.ndarray,
                 gamma_geom_full: np.ndarray,
                 D_int_full: np.ndarray,
                 rep_pairs: list,
                 UJ_full: np.ndarray):
        """
        All inputs are already represented on the full H = H_geom ⊗ H_SM ⊗ H_flav.

        rep_pairs: list of (a, b) represented operators used in A = Σ a [D, b]
        UJ_full: unitary implementing the antiunitary J = UJ ∘ K
        """
        self.D_geom = D_geom_full
        self.gamma_geom = gamma_geom_full
        self.D_int = D_int_full
        self.rep_pairs = rep_pairs
        self.UJ = UJ_full

        self.D = None
        self.A = None
        self.DA = None

    def build_D(self):
        # Even product form
        self.D = self.D_geom + (self.gamma_geom @ self.D_int)
        return self.D

    def build_A(self):
        if self.D is None:
            self.build_D()

        A1 = np.zeros_like(self.D, dtype=complex)
        for (a, b) in self.rep_pairs:
            comm = self.D @ b - b @ self.D
            A1 += a @ comm

        # Hermitian one-form
        self.A = 0.5 * (A1 + A1.conj().T)
        return self.A

    def build_DA(self):
        if self.D is None:
            self.build_D()
        if self.A is None:
            self.build_A()

        JAJinv = antiunitary_conjugation(self.UJ, self.A)
        self.DA = self.D + self.A + JAJinv
        return self.DA


def extract_lr(D_int: np.ndarray, P_L: np.ndarray, P_R: np.ndarray) -> np.ndarray:
    """
    Projector-defined LR extraction (no row slicing).
    Convention: L → R block is P_R D_int P_L.
    """
    return P_R @ D_int @ P_L
```
